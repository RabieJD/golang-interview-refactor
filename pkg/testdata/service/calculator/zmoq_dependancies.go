// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package calculator

import (
	"context"
	"interview/pkg/entity"
	"sync"
)

// CartRepoMock is a mock implementation of CartRepo.
//
//	func TestSomethingThatUsesCartRepo(t *testing.T) {
//
//		// make and configure a mocked CartRepo
//		mockedCartRepo := &CartRepoMock{
//			AddCartFunc: func(ctx context.Context, cart *entity.CartEntity) error {
//				panic("mock out the AddCart method")
//			},
//			DeleteItemFunc: func(ctx context.Context, itemID uint) error {
//				panic("mock out the DeleteItem method")
//			},
//			GetCartBySessionIDFunc: func(ctx context.Context, sessionID string) (*entity.CartEntity, error) {
//				panic("mock out the GetCartBySessionID method")
//			},
//			GetItemByCartIDAndNameFunc: func(ctx context.Context, cartID uint, name string) (*entity.CartItem, error) {
//				panic("mock out the GetItemByCartIDAndName method")
//			},
//			GetItemsByCartIDFunc: func(ctx context.Context, cartID uint) ([]*entity.CartItem, error) {
//				panic("mock out the GetItemsByCartID method")
//			},
//			UpdateCartFunc: func(ctx context.Context, cart *entity.CartEntity) error {
//				panic("mock out the UpdateCart method")
//			},
//			UpdateItemFunc: func(ctx context.Context, item *entity.CartItem) error {
//				panic("mock out the UpdateItem method")
//			},
//		}
//
//		// use mockedCartRepo in code that requires CartRepo
//		// and then make assertions.
//
//	}
type CartRepoMock struct {
	// AddCartFunc mocks the AddCart method.
	AddCartFunc func(ctx context.Context, cart *entity.CartEntity) error

	// DeleteItemFunc mocks the DeleteItem method.
	DeleteItemFunc func(ctx context.Context, itemID uint) error

	// GetCartBySessionIDFunc mocks the GetCartBySessionID method.
	GetCartBySessionIDFunc func(ctx context.Context, sessionID string) (*entity.CartEntity, error)

	// GetItemByCartIDAndNameFunc mocks the GetItemByCartIDAndName method.
	GetItemByCartIDAndNameFunc func(ctx context.Context, cartID uint, name string) (*entity.CartItem, error)

	// GetItemsByCartIDFunc mocks the GetItemsByCartID method.
	GetItemsByCartIDFunc func(ctx context.Context, cartID uint) ([]*entity.CartItem, error)

	// UpdateCartFunc mocks the UpdateCart method.
	UpdateCartFunc func(ctx context.Context, cart *entity.CartEntity) error

	// UpdateItemFunc mocks the UpdateItem method.
	UpdateItemFunc func(ctx context.Context, item *entity.CartItem) error

	// calls tracks calls to the methods.
	calls struct {
		// AddCart holds details about calls to the AddCart method.
		AddCart []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Cart is the cart argument value.
			Cart *entity.CartEntity
		}
		// DeleteItem holds details about calls to the DeleteItem method.
		DeleteItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ItemID is the itemID argument value.
			ItemID uint
		}
		// GetCartBySessionID holds details about calls to the GetCartBySessionID method.
		GetCartBySessionID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SessionID is the sessionID argument value.
			SessionID string
		}
		// GetItemByCartIDAndName holds details about calls to the GetItemByCartIDAndName method.
		GetItemByCartIDAndName []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CartID is the cartID argument value.
			CartID uint
			// Name is the name argument value.
			Name string
		}
		// GetItemsByCartID holds details about calls to the GetItemsByCartID method.
		GetItemsByCartID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CartID is the cartID argument value.
			CartID uint
		}
		// UpdateCart holds details about calls to the UpdateCart method.
		UpdateCart []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Cart is the cart argument value.
			Cart *entity.CartEntity
		}
		// UpdateItem holds details about calls to the UpdateItem method.
		UpdateItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Item is the item argument value.
			Item *entity.CartItem
		}
	}
	lockAddCart                sync.RWMutex
	lockDeleteItem             sync.RWMutex
	lockGetCartBySessionID     sync.RWMutex
	lockGetItemByCartIDAndName sync.RWMutex
	lockGetItemsByCartID       sync.RWMutex
	lockUpdateCart             sync.RWMutex
	lockUpdateItem             sync.RWMutex
}

// AddCart calls AddCartFunc.
func (mock *CartRepoMock) AddCart(ctx context.Context, cart *entity.CartEntity) error {
	if mock.AddCartFunc == nil {
		panic("CartRepoMock.AddCartFunc: method is nil but CartRepo.AddCart was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Cart *entity.CartEntity
	}{
		Ctx:  ctx,
		Cart: cart,
	}
	mock.lockAddCart.Lock()
	mock.calls.AddCart = append(mock.calls.AddCart, callInfo)
	mock.lockAddCart.Unlock()
	return mock.AddCartFunc(ctx, cart)
}

// AddCartCalls gets all the calls that were made to AddCart.
// Check the length with:
//
//	len(mockedCartRepo.AddCartCalls())
func (mock *CartRepoMock) AddCartCalls() []struct {
	Ctx  context.Context
	Cart *entity.CartEntity
} {
	var calls []struct {
		Ctx  context.Context
		Cart *entity.CartEntity
	}
	mock.lockAddCart.RLock()
	calls = mock.calls.AddCart
	mock.lockAddCart.RUnlock()
	return calls
}

// DeleteItem calls DeleteItemFunc.
func (mock *CartRepoMock) DeleteItem(ctx context.Context, itemID uint) error {
	if mock.DeleteItemFunc == nil {
		panic("CartRepoMock.DeleteItemFunc: method is nil but CartRepo.DeleteItem was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		ItemID uint
	}{
		Ctx:    ctx,
		ItemID: itemID,
	}
	mock.lockDeleteItem.Lock()
	mock.calls.DeleteItem = append(mock.calls.DeleteItem, callInfo)
	mock.lockDeleteItem.Unlock()
	return mock.DeleteItemFunc(ctx, itemID)
}

// DeleteItemCalls gets all the calls that were made to DeleteItem.
// Check the length with:
//
//	len(mockedCartRepo.DeleteItemCalls())
func (mock *CartRepoMock) DeleteItemCalls() []struct {
	Ctx    context.Context
	ItemID uint
} {
	var calls []struct {
		Ctx    context.Context
		ItemID uint
	}
	mock.lockDeleteItem.RLock()
	calls = mock.calls.DeleteItem
	mock.lockDeleteItem.RUnlock()
	return calls
}

// GetCartBySessionID calls GetCartBySessionIDFunc.
func (mock *CartRepoMock) GetCartBySessionID(ctx context.Context, sessionID string) (*entity.CartEntity, error) {
	if mock.GetCartBySessionIDFunc == nil {
		panic("CartRepoMock.GetCartBySessionIDFunc: method is nil but CartRepo.GetCartBySessionID was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		SessionID string
	}{
		Ctx:       ctx,
		SessionID: sessionID,
	}
	mock.lockGetCartBySessionID.Lock()
	mock.calls.GetCartBySessionID = append(mock.calls.GetCartBySessionID, callInfo)
	mock.lockGetCartBySessionID.Unlock()
	return mock.GetCartBySessionIDFunc(ctx, sessionID)
}

// GetCartBySessionIDCalls gets all the calls that were made to GetCartBySessionID.
// Check the length with:
//
//	len(mockedCartRepo.GetCartBySessionIDCalls())
func (mock *CartRepoMock) GetCartBySessionIDCalls() []struct {
	Ctx       context.Context
	SessionID string
} {
	var calls []struct {
		Ctx       context.Context
		SessionID string
	}
	mock.lockGetCartBySessionID.RLock()
	calls = mock.calls.GetCartBySessionID
	mock.lockGetCartBySessionID.RUnlock()
	return calls
}

// GetItemByCartIDAndName calls GetItemByCartIDAndNameFunc.
func (mock *CartRepoMock) GetItemByCartIDAndName(ctx context.Context, cartID uint, name string) (*entity.CartItem, error) {
	if mock.GetItemByCartIDAndNameFunc == nil {
		panic("CartRepoMock.GetItemByCartIDAndNameFunc: method is nil but CartRepo.GetItemByCartIDAndName was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		CartID uint
		Name   string
	}{
		Ctx:    ctx,
		CartID: cartID,
		Name:   name,
	}
	mock.lockGetItemByCartIDAndName.Lock()
	mock.calls.GetItemByCartIDAndName = append(mock.calls.GetItemByCartIDAndName, callInfo)
	mock.lockGetItemByCartIDAndName.Unlock()
	return mock.GetItemByCartIDAndNameFunc(ctx, cartID, name)
}

// GetItemByCartIDAndNameCalls gets all the calls that were made to GetItemByCartIDAndName.
// Check the length with:
//
//	len(mockedCartRepo.GetItemByCartIDAndNameCalls())
func (mock *CartRepoMock) GetItemByCartIDAndNameCalls() []struct {
	Ctx    context.Context
	CartID uint
	Name   string
} {
	var calls []struct {
		Ctx    context.Context
		CartID uint
		Name   string
	}
	mock.lockGetItemByCartIDAndName.RLock()
	calls = mock.calls.GetItemByCartIDAndName
	mock.lockGetItemByCartIDAndName.RUnlock()
	return calls
}

// GetItemsByCartID calls GetItemsByCartIDFunc.
func (mock *CartRepoMock) GetItemsByCartID(ctx context.Context, cartID uint) ([]*entity.CartItem, error) {
	if mock.GetItemsByCartIDFunc == nil {
		panic("CartRepoMock.GetItemsByCartIDFunc: method is nil but CartRepo.GetItemsByCartID was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		CartID uint
	}{
		Ctx:    ctx,
		CartID: cartID,
	}
	mock.lockGetItemsByCartID.Lock()
	mock.calls.GetItemsByCartID = append(mock.calls.GetItemsByCartID, callInfo)
	mock.lockGetItemsByCartID.Unlock()
	return mock.GetItemsByCartIDFunc(ctx, cartID)
}

// GetItemsByCartIDCalls gets all the calls that were made to GetItemsByCartID.
// Check the length with:
//
//	len(mockedCartRepo.GetItemsByCartIDCalls())
func (mock *CartRepoMock) GetItemsByCartIDCalls() []struct {
	Ctx    context.Context
	CartID uint
} {
	var calls []struct {
		Ctx    context.Context
		CartID uint
	}
	mock.lockGetItemsByCartID.RLock()
	calls = mock.calls.GetItemsByCartID
	mock.lockGetItemsByCartID.RUnlock()
	return calls
}

// UpdateCart calls UpdateCartFunc.
func (mock *CartRepoMock) UpdateCart(ctx context.Context, cart *entity.CartEntity) error {
	if mock.UpdateCartFunc == nil {
		panic("CartRepoMock.UpdateCartFunc: method is nil but CartRepo.UpdateCart was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Cart *entity.CartEntity
	}{
		Ctx:  ctx,
		Cart: cart,
	}
	mock.lockUpdateCart.Lock()
	mock.calls.UpdateCart = append(mock.calls.UpdateCart, callInfo)
	mock.lockUpdateCart.Unlock()
	return mock.UpdateCartFunc(ctx, cart)
}

// UpdateCartCalls gets all the calls that were made to UpdateCart.
// Check the length with:
//
//	len(mockedCartRepo.UpdateCartCalls())
func (mock *CartRepoMock) UpdateCartCalls() []struct {
	Ctx  context.Context
	Cart *entity.CartEntity
} {
	var calls []struct {
		Ctx  context.Context
		Cart *entity.CartEntity
	}
	mock.lockUpdateCart.RLock()
	calls = mock.calls.UpdateCart
	mock.lockUpdateCart.RUnlock()
	return calls
}

// UpdateItem calls UpdateItemFunc.
func (mock *CartRepoMock) UpdateItem(ctx context.Context, item *entity.CartItem) error {
	if mock.UpdateItemFunc == nil {
		panic("CartRepoMock.UpdateItemFunc: method is nil but CartRepo.UpdateItem was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Item *entity.CartItem
	}{
		Ctx:  ctx,
		Item: item,
	}
	mock.lockUpdateItem.Lock()
	mock.calls.UpdateItem = append(mock.calls.UpdateItem, callInfo)
	mock.lockUpdateItem.Unlock()
	return mock.UpdateItemFunc(ctx, item)
}

// UpdateItemCalls gets all the calls that were made to UpdateItem.
// Check the length with:
//
//	len(mockedCartRepo.UpdateItemCalls())
func (mock *CartRepoMock) UpdateItemCalls() []struct {
	Ctx  context.Context
	Item *entity.CartItem
} {
	var calls []struct {
		Ctx  context.Context
		Item *entity.CartItem
	}
	mock.lockUpdateItem.RLock()
	calls = mock.calls.UpdateItem
	mock.lockUpdateItem.RUnlock()
	return calls
}

// PriceRepoMock is a mock implementation of PriceRepo.
//
//	func TestSomethingThatUsesPriceRepo(t *testing.T) {
//
//		// make and configure a mocked PriceRepo
//		mockedPriceRepo := &PriceRepoMock{
//			GetPriceFunc: func(identifier string) (float64, error) {
//				panic("mock out the GetPrice method")
//			},
//		}
//
//		// use mockedPriceRepo in code that requires PriceRepo
//		// and then make assertions.
//
//	}
type PriceRepoMock struct {
	// GetPriceFunc mocks the GetPrice method.
	GetPriceFunc func(identifier string) (float64, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetPrice holds details about calls to the GetPrice method.
		GetPrice []struct {
			// Identifier is the identifier argument value.
			Identifier string
		}
	}
	lockGetPrice sync.RWMutex
}

// GetPrice calls GetPriceFunc.
func (mock *PriceRepoMock) GetPrice(identifier string) (float64, error) {
	if mock.GetPriceFunc == nil {
		panic("PriceRepoMock.GetPriceFunc: method is nil but PriceRepo.GetPrice was just called")
	}
	callInfo := struct {
		Identifier string
	}{
		Identifier: identifier,
	}
	mock.lockGetPrice.Lock()
	mock.calls.GetPrice = append(mock.calls.GetPrice, callInfo)
	mock.lockGetPrice.Unlock()
	return mock.GetPriceFunc(identifier)
}

// GetPriceCalls gets all the calls that were made to GetPrice.
// Check the length with:
//
//	len(mockedPriceRepo.GetPriceCalls())
func (mock *PriceRepoMock) GetPriceCalls() []struct {
	Identifier string
} {
	var calls []struct {
		Identifier string
	}
	mock.lockGetPrice.RLock()
	calls = mock.calls.GetPrice
	mock.lockGetPrice.RUnlock()
	return calls
}
